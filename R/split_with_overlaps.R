#' Splits signal to overlapping fragments of equal length. In case if the signal
#' is not completely divisible by given segment length, the function fills
#' missing data (NAs) with 3 most frequent values.
#'
#' @param signal character string. Name of the given ONT signal.
#' @param segment numeric [1]. Length of the chunk(s) to be created.
#' @param overlap numeric [1]. Length of the overlap between the chunks.
#'
#' @return a list object containing splitted chunks of signal.
#' @export
#'
#' @examples
#' \dontrun{
#'
#' split_with_overlaps <- function(signal='12fdcb3-ewfd543-34552-1234ddta345',
#'                                 segment = 300, overlap 100)
#'
#' }
#'
#'
#' # based on https://stackoverflow.com/questions/8872376/split-vector-with-overlapping-samples-in-r
#'
split_with_overlaps <- function(signal, segment, overlap) {
  starts <- seq(1, length(signal), by=segment-overlap)
  ends   <- starts + segment - 1
  most_freq_vals <- as.numeric(names(sort(table(signal),decreasing=TRUE)[1:3]))

  split_signal <- lapply(1:length(starts), function(i) signal[starts[i]:ends[i]])

  # replace NAs with 3 most frequent values
  #this is to avoid an error generated by cut() in gasf creator fun
  result_split <- lapply(split_signal, function(n) replace(n, is.na(n), as.integer(most_freq_vals)))

  return(result_split)
}
