################################################################################
# Testing plotting functions
################################################################################

# HELPER FUNCTIONS
################################################################################
#' Suppress plot-related warnings and messages (testing utility)
#'
#' Internal helper used in unit tests to silence warnings and
#' messages generated by plotting functions (e.g., \pkg{ggplot2}).
#'
#' @param expr An R expression to evaluate.
#'
#' @return The result of evaluating \code{expr}, with warnings and
#'   messages suppressed.
#'
#' @keywords internal
suppress_plot_warnings <- function(expr) {
  suppressWarnings(suppressMessages(expr))
}

#' Generate dummy nanopolish_qc summary data (testing utility)
#'
#' Internal helper function used in unit tests to create synthetic
#' QC summary tables. Produces either aggregated or per-sample
#' dummy read counts across predefined QC categories.
#'
#' @param grouped Logical. If \code{FALSE}, returns an aggregated
#'   summary table. If \code{TRUE}, returns per-sample summaries.
#'
#' @return A \code{data.frame} containing QC tags and dummy read counts.
#'
#' @keywords internal
create_test_processing_info <- function(grouped = FALSE) {
  qc_tags <- c("PASS",
               "ADAPTER",
               "SUFFCLIP",
               "NOREGION",
               "READ_FAILED_LOAD")

  if (!grouped) {
    data.frame(qc_tag = qc_tags,
               n = c(500, 50, 30, 15, 5),
               stringsAsFactors = FALSE)
  } else {
    rbind(
      data.frame(sample_name = "WT_1",
                 qc_tag = qc_tags,
                 n = c(250, 25, 15, 8, 2),
                 stringsAsFactors = FALSE),
      data.frame(sample_name = "KO_1",
                 qc_tag = qc_tags,
                 n = c(300, 30, 20, 10, 4),
                 stringsAsFactors = FALSE)
    )
  }
}


# plot_squiggle_fast5
################################################################################

test_that("plot_squiggle_fast5 correctly parses data & draws a signal plot", {
  empty_tempfile = tempfile()
  nanopolish = system.file('extdata', 'test_data', 'legacy', 'nanopolish_output.tsv', package = 'ninetails')
  sequencing_summary = system.file('extdata', 'test_data', 'legacy','sequencing_summary.txt', package = 'ninetails')
  test_workspace = system.file('extdata', 'test_data', 'legacy','basecalled_fast5', package = 'ninetails')
  uncalled_workspace= system.file('extdata', 'test_data', 'legacy', 'uncalled_fast5', package = 'ninetails')
  test_basecall_group = 'Basecall_1D_000'
  wrong_basecall_group = 'Basecall_1D_003'

  # wrong readname
  expect_error(plot_squiggle_fast5(readname = "this_is_a_wrong_readname",
                                   nanopolish = nanopolish,
                                   sequencing_summary = sequencing_summary,
                                   workspace = test_workspace,
                                   basecall_group = test_basecall_group,
                                   moves=FALSE,
                                   rescale=FALSE))
  # wrong workspace
  expect_error(plot_squiggle_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                   nanopolish = nanopolish,
                                   sequencing_summary = sequencing_summary,
                                   workspace = uncalled_workspace,
                                   basecall_group = test_basecall_group,
                                   moves=FALSE,
                                   rescale=FALSE))
  # wrong nanopolish
  expect_error(plot_squiggle_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                   nanopolish = empty_tempfile,
                                   sequencing_summary = sequencing_summary,
                                   workspace = test_workspace,
                                   basecall_group = test_basecall_group,
                                   moves=FALSE,
                                   rescale=FALSE))
  # wrong seq_sum
  expect_error(plot_squiggle_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                   nanopolish = nanopolish,
                                   sequencing_summary = empty_tempfile,
                                   workspace = test_workspace,
                                   basecall_group = test_basecall_group,
                                   moves=FALSE,
                                   rescale=FALSE))
  # wrong basecall group
  expect_error(plot_squiggle_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                   nanopolish = nanopolish,
                                   sequencing_summary = sequencing_summary,
                                   workspace = test_workspace,
                                   basecall_group = wrong_basecall_group,
                                   moves=FALSE,
                                   rescale=FALSE))

})



# plot_tail_range_fast5
################################################################################

test_that("plot_tail_range correctly parses data & draws a signal plot", {
  empty_tempfile = tempfile()
  nanopolish = system.file('extdata', 'test_data', 'legacy','nanopolish_output.tsv', package = 'ninetails')
  sequencing_summary = system.file('extdata', 'test_data', 'legacy','sequencing_summary.txt', package = 'ninetails')
  test_workspace = system.file('extdata', 'test_data', 'legacy','basecalled_fast5', package = 'ninetails')
  uncalled_workspace= system.file('extdata', 'test_data', 'legacy', 'uncalled_fast5', package = 'ninetails')
  test_basecall_group = 'Basecall_1D_000'
  wrong_basecall_group = 'Basecall_1D_003'

  # wrong readname
  expect_error(plot_tail_range_fast5(readname = "this_is_a_wrong_readname",
                                     nanopolish = nanopolish,
                                     sequencing_summary = sequencing_summary,
                                     workspace = test_workspace,
                                     basecall_group = test_basecall_group,
                                     moves=FALSE,
                                     rescale=FALSE))
  # wrong workspace
  expect_error(plot_tail_range_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                     nanopolish = nanopolish,
                                     sequencing_summary = sequencing_summary,
                                     workspace = uncalled_workspace,
                                     basecall_group = test_basecall_group,
                                     moves=FALSE,
                                     rescale=FALSE))
  # wrong nanopolish
  expect_error(plot_tail_range_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                     nanopolish = empty_tempfile,
                                     sequencing_summary = sequencing_summary,
                                     workspace = test_workspace,
                                     basecall_group = test_basecall_group,
                                     moves=FALSE,
                                     rescale=FALSE))
  # wrong seq_sum
  expect_error(plot_tail_range_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                     nanopolish = nanopolish,
                                     sequencing_summary = empty_tempfile,
                                     workspace = test_workspace,
                                     basecall_group = test_basecall_group,
                                     moves=FALSE,
                                     rescale=FALSE))
  # wrong basecall group
  expect_error(plot_tail_range_fast5(readname = "9c11d71e-eaaa-413f-958e-4ca1254e0369",
                                     nanopolish = nanopolish,
                                     sequencing_summary = sequencing_summary,
                                     workspace = test_workspace,
                                     basecall_group = wrong_basecall_group,
                                     moves=FALSE,
                                     rescale=FALSE))


})


# plot_tail_chunk
################################################################################

test_that("plot_tail_chunk validates required arguments", {
  # wrong tail chunk list
  expect_error(plot_tail_chunk(chunk_name = "test_chunk"),
    "List of tail chunks is missing")

  # wrong chunkname
  expect_error(plot_tail_chunk(tail_chunk_list = list()),
    "Chunk_name is missing")

  # wrong input
  expect_error( plot_tail_chunk(chunk_name = "test", tail_chunk_list = "not_a_list"),
    "not a list")
})


test_that("plot_tail_chunk returns ggplot object for valid input", {

  skip_if_not_installed("ggplot2")
  skip_if(!exists("test_tail_chunk_list"), "test_tail_chunk_list not loaded")

  # Get first valid chunk name from the test data
  chunk_names <- unlist(lapply(test_tail_chunk_list, names))
  skip_if(length(chunk_names) == 0, "No chunks in test_tail_chunk_list")

  first_chunk <- chunk_names[1]

  result <- suppress_plot_warnings(plot_tail_chunk(chunk_name = first_chunk,
                                                   tail_chunk_list = test_tail_chunk_list))

  expect_s3_class(result, "gg")
  expect_s3_class(result, "ggplot")
})


# plot_gaf
################################################################################

test_that("plot_gaf validates required arguments", {

  expect_error(plot_gaf(gaf_list = list()),"Gaf_name is missing")

  expect_error(plot_gaf(gaf_name = "test"),"List of GAFs is missing")

  expect_error(plot_gaf(gaf_name = "test", gaf_list = "not_a_list"),"not a list")
})


test_that("plot_gaf validates gaf_name exists in gaf_list", {
  skip_if(!exists("test_gaf_list"), "test_gaf_list not loaded")

  expect_error(plot_gaf(gaf_name = "nonexistent_gaf",
                        gaf_list = test_gaf_list),
               "does not contain provided gaf_name")
})


test_that("plot_gaf returns ggplot object for valid input", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("reshape2")
  skip_if(!exists("test_gaf_list"), "test_gaf_list not loaded")
  skip_if(length(test_gaf_list) == 0, "test_gaf_list is empty")

  first_gaf_name <- names(test_gaf_list)[1]

  result <- suppress_plot_warnings(plot_gaf(gaf_name = first_gaf_name,
                                            gaf_list = test_gaf_list,
                                            save_file = FALSE))

  expect_s3_class(result, "gg")
  expect_s3_class(result, "ggplot")
})


test_that("plot_gaf rejects broken gaf_list structure",{
  skip_if(!exists("gaf_list_broken"), "gaf_list_broken not loaded")
  skip_if(length(gaf_list_broken) == 0, "gaf_list_broken is empty")

  # The broken gaf_list should cause issues during plotting
  # This is chunk with wrong values
  gaf_name <- names(gaf_list_broken)[16]

  # Expecting an error when trying to plot malformed GAF
  expect_error(invisible(print(plot_gaf(gaf_name = gaf_name,
                                        gaf_list = gaf_list_broken,
                                        save_file = FALSE))))
})



# plot_multiple_gaf
################################################################################

test_that("plot_multiple_gaf validates required arguments", {
  expect_error(plot_multiple_gaf(num_cores = 1),"List of GAFs is missing")

  expect_error(plot_multiple_gaf(gaf_list = list()),"Number of declared cores is missing")

  expect_error(plot_multiple_gaf(gaf_list = "not_a_list",num_cores = 1),"not a list")

  expect_error(plot_multiple_gaf(gaf_list = list(a = 1), num_cores = "one"),"must be numeric")
})


# plot_class_counts
################################################################################

test_that("plot_class_counts validates required arguments", {
  expect_error(
    plot_class_counts(),
    "Class_data is missing"
  )

  expect_error(
    plot_class_counts(class_data = data.frame()),
    "Empty data frame"
  )

  expect_error(
    plot_class_counts(
      class_data = class_data_single,
      frequency = "yes"
    ),
    "Non-boolean"
  )

  expect_error(
    plot_class_counts(
      class_data = class_data_single,
      type = 123
    ),
    "Non-character"
  )
})


test_that("plot_class_counts returns ggplot for ungrouped data", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("dplyr")
  skip_if(!exists("class_data_single"), "class_data_single not loaded")

  # Type R - detailed (comments)
  result_r <- suppress_plot_warnings(plot_class_counts(class_data = class_data_single,
                                                       type = "R"))
  expect_s3_class(result_r, "gg")

  # Type N - crude (class)
  result_n <- suppress_plot_warnings(plot_class_counts(class_data = class_data_single,
                                                       type = "N"))
  expect_s3_class(result_n, "gg")
})


test_that("plot_class_counts returns ggplot for grouped data", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("dplyr")
  skip_if(!exists("class_data_grouped"), "class_data_grouped not loaded")

  # With grouping factor and frequency
  result_freq <- suppress_plot_warnings(
    plot_class_counts(class_data = class_data_grouped,
                      grouping_factor = "sample_name",
                      frequency = TRUE,
                      type = "R"))

  expect_s3_class(result_freq, "gg")

  # With grouping factor and counts
  result_count <- suppress_plot_warnings(
    plot_class_counts(class_data = class_data_grouped,
                      grouping_factor = "sample_name",
                      frequency = FALSE,
                      type = "N"))

  expect_s3_class(result_count, "gg")
})



# plot_residue_counts
################################################################################

test_that("plot_residue_counts validates required arguments", {
  expect_error(plot_residue_counts(),"Residue_data dataframe is missing")

  expect_error(plot_residue_counts(residue_data = data.frame()), "Empty data frame")
})


test_that("plot_residue_counts returns ggplot for ungrouped data", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("dplyr")
  skip_if(!exists("residue_data_single"), "residue_data_single not loaded")

  # Default (by residue)
  result <- suppress_plot_warnings(plot_residue_counts(residue_data = residue_data_single))
  expect_s3_class(result, "gg")

  # By read
  result_by_read <- suppress_plot_warnings(
    plot_residue_counts(residue_data = residue_data_single,
                        by_read = TRUE))

  expect_s3_class(result_by_read, "gg")
})


test_that("plot_residue_counts returns ggplot for grouped data", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("dplyr")
  skip_if_not_installed("tidyr")
  skip_if(!exists("residue_data_grouped"), "residue_data_grouped not loaded")

  # With grouping factor and frequency
  result_freq <- suppress_plot_warnings(plot_residue_counts(
    residue_data = residue_data_grouped,
    grouping_factor = "group",
    frequency = TRUE))

  expect_s3_class(result_freq, "gg")

  # With grouping factor and counts
  result_count <- suppress_plot_warnings(
    plot_residue_counts(residue_data = residue_data_grouped,
                        grouping_factor = "group",
                        frequency = FALSE))

  expect_s3_class(result_count, "gg")
})


# plot_nanopolish_qc
################################################################################

test_that("plot_nanopolish_qc validates required arguments", {
  expect_error(plot_nanopolish_qc(),"Nanopolish processing info is missing")

  expect_error(plot_nanopolish_qc(processing_info = data.frame()),"Empty data frame")

  # Missing required columns
  bad_df <- data.frame(a = 1, b = 2)
  expect_error(plot_nanopolish_qc(processing_info = bad_df),"qc_tag column is missing")

  # Wrong type for frequency
  good_df <- create_test_processing_info(grouped = FALSE)
  expect_error(plot_nanopolish_qc(processing_info = good_df,frequency = "yes"),"Non-boolean")

})


test_that("plot_nanopolish_qc returns ggplot for ungrouped data", {
  skip_if_not_installed("ggplot2")

  processing_info <- create_test_processing_info(grouped = FALSE)

  result <- suppress_plot_warnings(plot_nanopolish_qc(processing_info = processing_info,
                                                      frequency = TRUE))

  expect_s3_class(result, "gg")

  result_count <- suppress_plot_warnings(plot_nanopolish_qc(processing_info = processing_info,
                                                            frequency = FALSE))

  expect_s3_class(result_count, "gg")
})


test_that("plot_nanopolish_qc returns ggplot for grouped data", {
  skip_if_not_installed("ggplot2")

  processing_info <- create_test_processing_info(grouped = TRUE)

  result_freq <- suppress_plot_warnings(plot_nanopolish_qc(processing_info = processing_info,
                                                           frequency = TRUE))

  expect_s3_class(result_freq, "gg")

  result_count <- suppress_plot_warnings(plot_nanopolish_qc(processing_info = processing_info,
                                                            frequency = FALSE))

  expect_s3_class(result_count, "gg")
})



# plot_tail_distribution
################################################################################

test_that("plot_tail_distribution validates required arguments", {
  expect_error(plot_tail_distribution(),"Ninetails data are missing")

  expect_error(plot_tail_distribution(input_data = residue_data_single,
                                      variable_to_plot = 123),"must be a string")
})


test_that("plot_tail_distribution validates grouping_factor exists", {
  skip_if(!exists("residue_data_single"), "residue_data_single not loaded")

  expect_error(plot_tail_distribution(
    input_data = residue_data_single,
    grouping_factor = "nonexistent_column"),"is not a column")
})


test_that("plot_tail_distribution returns ggplot for polya_length", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("dplyr")
  skip_if(!exists("merged_nonA_char"), "merged_nonA_char not loaded")

  result <- suppress_plot_warnings(plot_tail_distribution(input_data = merged_nonA_char,
                                                          variable_to_plot = "polya_length",
                                                          grouping_factor = "group",
                                                          max_length = 200,
                                                          ndensity = TRUE,
                                                          title = TRUE))

  expect_s3_class(result, "gg")
})


test_that("plot_tail_distribution returns ggplot for est_nonA_pos", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("dplyr")
  skip_if(!exists("residue_data_grouped"), "residue_data_grouped not loaded")

  result <- suppress_plot_warnings(plot_tail_distribution(input_data = residue_data_grouped,
                                                          variable_to_plot = "est_nonA_pos",
                                                          grouping_factor = "group",
                                                          max_length = 150,
                                                          ndensity = TRUE,
                                                          title = FALSE))

  expect_s3_class(result, "gg")
})


test_that("plot_tail_distribution shows central tendency measures", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("dplyr")
  skip_if(!exists("merged_nonA_char"), "merged_nonA_char not loaded")

  # Test median
  result_median <- suppress_plot_warnings(
    plot_tail_distribution(
      input_data = merged_nonA_char,
      variable_to_plot = "polya_length",
      grouping_factor = "group",
      value_to_show = "median"
    )
  )
  expect_s3_class(result_median, "gg")

  # Test mean
  result_mean <- suppress_plot_warnings(plot_tail_distribution(input_data = merged_nonA_char,
                                                               variable_to_plot = "polya_length",
                                                               grouping_factor = "group",
                                                               value_to_show = "mean"))

  expect_s3_class(result_mean, "gg")

  # Test mode
  result_mode <- suppress_plot_warnings(plot_tail_distribution(input_data = merged_nonA_char,
                                                               variable_to_plot = "polya_length",
                                                               grouping_factor = "group",
                                                               value_to_show = "mode"))

  expect_s3_class(result_mode, "gg")
})



# plot_panel_characteristics
################################################################################

test_that("plot_panel_characteristics returns plot with class_data", {

  skip_if_not_installed("ggplot2")
  skip_if_not_installed("patchwork")
  skip_if(!exists("residue_data_grouped"), "residue_data_grouped not loaded")
  skip_if(!exists("class_data_grouped"), "class_data_grouped not loaded")

  # overwrite multiple groups with one group
  class_dat <- class_data_grouped
  res_dat <- residue_data_grouped

  class_dat$group <- "WT"
  res_dat$group   <- "WT"

  # Use grouped data which has required 'group' column
  result <- suppress_plot_warnings(
    plot_panel_characteristics(input_residue_data = res_dat,
                               input_class_data = class_dat,
                               type = "default",
                               max_length = 200,
                               direction_5_prime = TRUE))

  expect_true(!is.null(result))
})


test_that("plot_panel_characteristics returns plot with merged data", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("patchwork")
  skip_if(!exists("residue_data_grouped"), "residue_data_grouped not loaded")
  skip_if(!exists("merged_nonA_num"), "merged_nonA_num not loaded")

  # overwrite multiple groups with one group
  merged_nonA <- merged_nonA_num
  res_dat <- residue_data_grouped

  merged_nonA$group <- "WT"
  res_dat$group   <- "WT"

  # Use grouped residue data which has required 'group' column
  result <- suppress_plot_warnings(
    plot_panel_characteristics(input_residue_data = res_dat,
                               input_merged_nonA_tables_data = merged_nonA,
                               type = "default",
                               max_length = 200))

  expect_true(!is.null(result))
})




test_that("plot_panel_characteristics errors when multiple groups present (class_data)", {

  skip_if_not_installed("ggplot2")
  skip_if_not_installed("patchwork")

  skip_if(!exists("residue_data_grouped"), "residue_data_grouped not loaded")
  skip_if(!exists("class_data_grouped"), "class_data_grouped not loaded")

  # Use original grouped data (contains multiple groups)
  expect_error(suppress_plot_warnings(
    plot_panel_characteristics(
      input_residue_data = residue_data_grouped,
      input_class_data = class_data_grouped,
      type = "default",
      max_length = 200,
      direction_5_prime = TRUE)))
})



test_that("plot_panel_characteristics errors when multiple groups present (merged_nonA)", {

  skip_if_not_installed("ggplot2")
  skip_if_not_installed("patchwork")

  skip_if(!exists("residue_data_grouped"), "residue_data_grouped not loaded")
  skip_if(!exists("merged_nonA_num"), "merged_nonA_num not loaded")

  # Use original grouped data (contains multiple groups)
  expect_error(suppress_plot_warnings(
    plot_panel_characteristics(
      input_residue_data = residue_data_grouped,
      input_merged_nonA_tables_data = merged_nonA_num,
      type = "default",
      max_length = 200,
      direction_5_prime = TRUE)))
})








# plot_rug_density
################################################################################

test_that("plot_rug_density validates base argument", {
  skip_if(!exists("residue_data_single"), "residue_data_single not loaded")

  expect_error(plot_rug_density(residue_data = residue_data_single,
                                base = "A",
                                max_length = 100),"Wrong base")

  expect_error(plot_rug_density(residue_data = residue_data_single,
                                base = "X",
                                max_length = 100),"Wrong base")
})


test_that("plot_rug_density returns plot-like object for valid bases", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("cowplot")
  skip_if_not_installed("dplyr")
  skip_if(!exists("residue_data_single"), "residue_data_single not loaded")

  # Test C
  result_c <- suppress_plot_warnings(
    plot_rug_density(residue_data = residue_data_single,
                     base = "C",
                     max_length = 150))

  # cowplot returns different class, check it's not null
  expect_true(!is.null(result_c))

  # Test G
  result_g <- suppress_plot_warnings(
    plot_rug_density(residue_data = residue_data_single,
                     base = "G",
                     max_length = 150))

  expect_true(!is.null(result_g))

  # Test U
  result_u <- suppress_plot_warnings(
    plot_rug_density(residue_data = residue_data_single,
                     base = "U",
                     max_length = 150))

  expect_true(!is.null(result_u))
})


test_that("plot_rug_density works with grouped residue data", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("cowplot")
  skip_if_not_installed("dplyr")
  skip_if(!exists("residue_data_grouped"), "residue_data_grouped not loaded")

  result <- suppress_plot_warnings(
    plot_rug_density(residue_data = residue_data_grouped,
                     base = "G",
                     max_length = 150))

  expect_true(!is.null(result))
})




# plot_nonA_abundance
################################################################################

# Helper: Create residue data with reads having 1, 2, and 3+ non-A residues
create_residue_data_for_abundance <- function() {
  data.frame(
    readname = c(
      # Single non-A reads
      "read_single_1", "read_single_2", "read_single_3",
      # Two non-A reads (same readname appears twice)
      "read_two_1", "read_two_1","read_two_2", "read_two_2",
      # Three+ non-A reads (same readname appears 3+ times)
      "read_more_1", "read_more_1", "read_more_1","read_more_2",
      "read_more_2", "read_more_2", "read_more_2"),
    contig = rep("beta_gal", 14),
    prediction = c("G", "C", "U","G", "C","U", "G","G", "C", "U","G", "C", "U", "G"),
    est_nonA_pos = c(30, 45, 60,20, 50,25, 55,10, 30, 50,15, 35, 55, 75),
    polya_length = c(100, 120, 80,90, 90,110, 110,130, 130, 130,150, 150, 150, 150),
    qc_tag = rep(60, 14),
    sample_name = c(rep("WT_1", 7),rep("KO_1", 7)),
    group = c(rep("WT", 7),rep("KO", 7)),
    stringsAsFactors = FALSE)
}


test_that("plot_nonA_abundance returns ggplot object", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("tidyr")
  skip_if_not_installed("dplyr")

  # Use helper data that has single, two, and more categories
  test_residue_data <- create_residue_data_for_abundance()

  result <- suppress_plot_warnings(
    ninetails::plot_nonA_abundance(residue_data = test_residue_data,
                                   grouping_factor = "sample_name"))

  expect_s3_class(result, "gg")
  expect_s3_class(result, "ggplot")
})


test_that("plot_nonA_abundance works with group column", {
  skip_if_not_installed("ggplot2")
  skip_if_not_installed("tidyr")
  skip_if_not_installed("dplyr")

  # Use helper data that has single, two, and more categories
  test_residue_data <- create_residue_data_for_abundance()

  result <- suppress_plot_warnings(
    ninetails::plot_nonA_abundance(residue_data = test_residue_data,
                                   grouping_factor = "group"))

  expect_s3_class(result, "gg")
})
