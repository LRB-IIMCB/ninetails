% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ninetails_core_functions_dorado_DRS.R
\name{filter_signal_by_threshold_vectorized}
\alias{filter_signal_by_threshold_vectorized}
\title{Detection of outliers (peaks & valleys) in ONT signal using z-scores (Ultra-fast vectorized version).}
\usage{
filter_signal_by_threshold_vectorized(signal)
}
\arguments{
\item{signal}{A numeric vector representing the raw Oxford Nanopore signal
corresponding to the poly(A) tail region. Signal values should be current
measurements in picoamperes. Minimum length is 10 data points.}
}
\value{
A numeric vector of "pseudomoves" with the same length as the input
  signal (after calibration data removal). Values are integers in the range
  \{-1, 0, 1\} representing:
  \describe{
    \item{-1}{Signal valleys (potential C/U nucleotides)}
    \item{0}{Normal signal (likely A nucleotides)}
    \item{1}{Signal peaks (potential G nucleotides)}
  }
}
\description{
This function provides an ultra-fast, highly vectorized implementation for detecting
signal outliers in Oxford Nanopore poly(A) tail sequences. It identifies areas where
the signal significantly deviates from typical adenosine homopolymer values, which
may indicate the presence of non-adenosine nucleotides (C, G, U).
}
\details{
The algorithm uses a robust peak detection approach based on z-scores with adaptive
windowing to distinguish between normal adenosine signal and potential modifications.
This vectorized implementation prioritizes performance through efficient memory usage,
reduced function calls, and optimized statistical calculations.
}
\section{Algorithm Details}{

The function implements a sliding window approach where:
\itemize{
  \item A calibration phase establishes baseline signal characteristics
  \item Rolling statistics (mean, standard deviation) are computed for each position
  \item Outliers are detected when signal deviates >3.5 standard deviations from local mean
  \item Direction of deviation determines pseudomove value: +1 (peaks), -1 (valleys), 0 (normal)
}
}

\section{Performance Optimizations}{

This vectorized version includes several performance improvements:
\itemize{
  \item Vectorized statistical calculations (sum/length instead of mean())
  \item Efficient rolling window operations
  \item Reduced memory allocations and copying
  \item Minimized function call overhead
  \item Integer operations where appropriate
}
}

\section{Output Interpretation}{

The returned pseudomove vector contains:
\itemize{
  \item \strong{1}: Signal significantly above baseline (potential G nucleotides)
  \item \strong{0}: Signal within normal range (likely A nucleotides)
  \item \strong{-1}: Signal significantly below baseline (potential C/U nucleotides)
}
}

\section{Quality Control}{

The function applies several quality control measures:
\itemize{
  \item Terminal position masking (first 5 positions set to 0)
  \item Gap substitution to handle segmentation artifacts
  \item Calibration using most frequent signal values
  \item Reproducible random seed for consistent results
}
}

\section{References}{

The peak detection algorithm is based on:
Brakel, J.P.G. van (2014). "Robust peak detection algorithm using z-scores".
Stack Overflow. Available at:
\url{https://stackoverflow.com/questions/22583391/peak-signal-detection-in-realtime-timeseries-data/22640362#22640362}
(version: 2020-11-08).
}

\section{Implementation Notes}{

\itemize{
  \item Uses a fixed random seed (123) for reproducible results
  \item Window size is fixed at 100 data points
  \item Z-score threshold is set to 3.5 standard deviations
  \item Calibration uses 100 synthetic data points
  \item Terminal positions (first 5) are masked to prevent false positives
}
}

\section{Performance}{

Expected performance improvements over the original implementation:
\itemize{
  \item 3-5x faster execution time for typical signal lengths
  \item Reduced memory usage by approximately 30-50\%
  \item Better scaling for large signals (>10,000 data points)
}
}

\examples{
\dontrun{
# Basic usage with a signal vector
pseudomoves <- filter_signal_by_threshold_vectorized(tail_signal)

# Example with simulated poly(A) signal
set.seed(42)
simulated_signal <- c(
  rnorm(100, mean = 650, sd = 15),  # Normal A signal
  rnorm(20, mean = 700, sd = 10),   # G-like peak
  rnorm(50, mean = 645, sd = 12),   # More A signal
  rnorm(15, mean = 580, sd = 8)     # C/U-like valley
)

# Detect modifications
pseudomoves <- filter_signal_by_threshold_vectorized(simulated_signal)

# Visualize results
plot(simulated_signal, type = "l", main = "Signal with Detected Modifications")
points(which(pseudomoves == 1), simulated_signal[which(pseudomoves == 1)],
       col = "red", pch = 16)  # Peaks
points(which(pseudomoves == -1), simulated_signal[which(pseudomoves == -1)],
       col = "blue", pch = 16) # Valleys

# Integration with ninetails pipeline
# This function is typically called within create_tail_features_list_dorado()
features <- create_tail_features_list_dorado(
  signal_list = list("read1" = tail_signal),
  num_cores = 1
)
}

}
\seealso{
\code{\link{filter_signal_by_threshold}} for the original implementation,
\code{\link{substitute_gaps}} for gap handling,
\code{\link{create_tail_features_list_dorado}} for the complete feature extraction pipeline
}
\concept{optimization_functions}
\concept{pseudomove_functions}
\concept{signal_processing}
