% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ninetails_core_functions.R
\name{create_outputs}
\alias{create_outputs}
\title{Creates the list object containing tabular outputs of ninetails pipeline.}
\usage{
create_outputs(
  tail_feature_list,
  tail_chunk_list,
  nanopolish,
  predicted_list,
  num_cores,
  pass_only = TRUE,
  qc = TRUE
)
}
\arguments{
\item{tail_feature_list}{list object produced by create_tail_feature_list
function.}

\item{tail_chunk_list}{list object produced by create_tail_chunk_list
function.}

\item{nanopolish}{character string. Full path of the .tsv file produced
by nanopolish polya function or name of in-memory file (environment object).}

\item{predicted_list}{a list object produced by predict_classes function.}

\item{num_cores}{numeric [1]. Number of physical cores to use in processing
the data. Do not exceed 1 less than the number of cores at your disposal.}

\item{pass_only}{logical [TRUE/FALSE]. If TRUE, only reads tagged by
nanopolish as "PASS" would be taken into consideration. Otherwise, reads
tagged as "PASS" & "SUFFCLIP" will be taken into account in analysis.
As a default, "TRUE" value is set.}

\item{qc}{logical [TRUE/FALSE]. If TRUE, the quality control of the output
predictions would be performed. This means that the reads/non-A residue
positions in terminal nucleotides, which are most likely artifacts, are
labeled accordingly as "-WARN" (residues recognized as non-A due to
nanopolish segmentation error which is inherited from nanopolish,
as ninetails uses nanopolish segmentation). It is then up to user, whether
they would like to include or discard such reads from their pipeline. However,
it is advised to treat them with caution. By default, the qc option is enabled
(this parameter is set to TRUE).}
}
\value{
This function returns a list object containing two fataframes:
"read_classes" and "nonadenosine_residues" with the final output.
First dataframe contains initial indications, whether the given read was
classified or omitted (with reason) and if classified, whether read was
recognized as modified (containing non-adenosine residue) or not.
The second dataframe contains detailed info on type and estimated positions
of non-adenosine residues detected.
}
\description{
The read_classes dataframe contains results of read classification.
The sequencing reads are assigned to classes based on whether the initial
conditions are met or not (e.g. sufficient read quality, sufficient length
(>=10 nt), move transition presence, local signal anomaly detected etc.).
According to this, reads are assigned into 3 main categories: modified,
unmodified, unclassified (class column).
}
\details{
The more detailed info regarding read classification is stored within
'comments' column. To make the output more compact, it contains codes
as follows:\itemize{
\item IRL - insufficient read length
\item QCF - nanopolish qc failed
\item MAU - move transition absent, nonA residue undetected
\item MPU - move transition present, nonA residue undetected
\item NIN - not included in the analysis (pass only = T)
\item YAY - move transition present, nonA residue detected
}

The nonadenosine_residues contains detailed positional info regarding all
potential nonadenosine residues detected.
}
\examples{
\dontrun{

create_outputs(tail_feature_list = tail_feature_list,
               tail_chunk_list = tail_chunk_list,
               nanopolish = '/path/to/nanopolish_output.tsv',
               predicted_list = predicted_list,
               num_cores = 2,
               pass_only=TRUE,
               qc=TRUE)
}


}
