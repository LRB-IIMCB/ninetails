% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ninetails_core_functions_dorado_DRS.R,
%   R/parallelization.R
\name{extract_tails_from_pod5}
\alias{extract_tails_from_pod5}
\title{Extract poly(A) tail signal segments from POD5 files using parallel Python processing}
\usage{
extract_tails_from_pod5(polya_data, pod5_dir, num_cores = 1)

extract_tails_from_pod5(polya_data, pod5_dir, num_cores = 1)
}
\arguments{
\item{polya_data}{Data frame with columns: read_id, filename, poly_tail_start, poly_tail_end}

\item{pod5_dir}{Character. Path to the directory containing POD5 files}

\item{num_cores}{Integer. Number of cores to use (default: 1)}
}
\value{
A named list of numeric vectors, where:
  \itemize{
    \item Names correspond to read_id values from the input
    \item Each vector contains the winsorized and interpolated signal values
    \item Empty vectors indicate reads where extraction failed
  }
  Returns an empty list if no valid reads are found.

List of numeric vectors containing extracted signals
}
\description{
This function extracts raw nanopore signal data corresponding to poly(A) tail regions
from POD5 format files. It leverages a Python subprocess for efficient parallel
extraction, avoiding R-Python serialization bottlenecks inherent in reticulate.
The function processes multiple reads across multiple POD5 files simultaneously,
applies winsorization to reduce noise, and performs signal interpolation to
standardize tail representations.
}
\details{
The function performs the following operations:
\enumerate{
  \item \strong{Input validation}: Checks for required columns and valid data
  \item \strong{Read filtering}: Excludes reads with:
    \itemize{
      \item poly_tail_length ≤ 10 (if column exists)
      \item poly_tail_start ≤ 0 (invalid coordinates)
    }
  \item \strong{Python subprocess execution}: Delegates extraction to an optimized
        Python script that:
    \itemize{
      \item Groups reads by POD5 file for efficient I/O
      \item Processes files in parallel using multiprocessing
      \item Extracts signal segments based on provided coordinates
    }
  \item \strong{Signal processing}: For each valid tail region:
    \itemize{
      \item Applies winsorization (0.5% and 99.5% percentiles)
      \item Interpolates to 20% of original length for standardization
      \item Converts to integer values for downstream compatibility
    }
}

The Python subprocess approach bypasses reticulate's Global Interpreter Lock (GIL)
limitations, providing true parallel processing for large datasets. Temporary files
are used for data exchange and automatically cleaned up after processing.
}
\note{
\itemize{
  \item Requires Dorado >=1.0.0 to retrieve polyA coordinates
  \item Requires Python 3.6+ with the 'pod5' module installed: \code{pip install pod5}
  \item The POD5 extraction script must be present at
        \code{system.file("extdata", "extract_pod5_signals.py", package = "ninetails")}
  \item Large datasets may require substantial temporary disk space
  \item Progress messages are printed directly from the Python subprocess
}
}
\examples{
\dontrun{
# Load poly(A) coordinate data
polya_data <- read.table("polya_coords.txt", header = TRUE)

# Extract signals using 4 cores
signals <- extract_tails_from_pod5(
  polya_data = polya_data,
  pod5_dir = "/path/to/pod5/files/",
  num_cores = 4
)}

}
\seealso{
\code{\link{create_tail_features_list_dorado}} for computing pseudomoves from signals,
\code{\link{process_dorado_signal_files}} for complete signal processing pipeline
}
