% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tailfindr_compatibility.R
\name{convert_tailfindr_output}
\alias{convert_tailfindr_output}
\title{Converts tailfindr results to format compatible with ninetails}
\usage{
convert_tailfindr_output(tailfindr_output)
}
\arguments{
\item{tailfindr_output}{Character string or data frame. Either the full
path of the \code{.csv} file produced by tailfindr, or an in-memory
data frame containing tailfindr result data. Required columns:
\code{read_id}, \code{tail_start}, \code{tail_end},
\code{tail_length}.}
}
\value{
A tibble containing tailfindr results reformatted to resemble
  the output of \code{nanopolish polya}, with columns:
\describe{
  \item{readname}{Character. Read identifier (renamed from
    \code{read_id}).}
  \item{polya_start}{Integer. Start coordinate of the poly(A) tail
    (renamed from \code{tail_start}).}
  \item{tail_end}{Integer. End coordinate of the poly(A) tail
    (retained from tailfindr).}
  \item{polya_length}{Numeric. Estimated tail length (renamed from
    \code{tail_length}).}
  \item{transcript_start}{Integer. Transcript start coordinate
    (\code{tail_end + 1}).}
  \item{contig}{Character. Dummy mapping target
    (\code{"tailfindr_out"}).}
  \item{qc_tag}{Character. Quality tag (\code{"PASS"} or
    \code{"NOREGION"}).}
}
Always assign this returned tibble to a variable; printing the full
tibble to the console may crash the R session.
}
\description{
Reformats the output of the tailfindr pipeline so it can be passed
to the ninetails legacy (Guppy) pipeline in place of nanopolish polya
output. The function renames key columns, creates derived columns, and
introduces dummy quality tags to approximate the nanopolish output
schema.
}
\details{
The following column mappings are applied:
\describe{
  \item{\code{read_id} \eqn{\rightarrow} \code{readname}}{Read identifier
    renamed to match the ninetails naming convention.}
  \item{\code{tail_start} \eqn{\rightarrow} \code{polya_start}}{Start
    coordinate of the poly(A) tail.}
  \item{\code{tail_length} \eqn{\rightarrow} \code{polya_length}}{Estimated
    poly(A) tail length.}
}

The following columns are created:
\describe{
  \item{\code{transcript_start}}{Set to \code{tail_end + 1}.}
  \item{\code{contig}}{Dummy value \code{"tailfindr_out"} (nanopolish
    returns mapping information, which is absent in tailfindr output).}
  \item{\code{qc_tag}}{Simplified quality tag. Because the R9.4.1 pore
    detection region spans 5 nucleotides, tails shorter than 10 nt
    (2 full adjacent 5-mers with no overlap) are unreliable. Therefore
    \code{qc_tag} is set to \code{"PASS"} for tails >= 10 nt and
    \code{"NOREGION"} otherwise.}
}
}
\section{Warning}{

Ninetails is optimised to work with nanopolish polya output. The
HMM-based approach of nanopolish provides more robust tail boundary
predictions than the slope estimator used by tailfindr. In particular,
ninetails relies on the quality tags produced by nanopolish
(\code{"PASS"} / \code{"SUFFCLIP"}). When using tailfindr output, the
signal quality cannot be inferred, which may lead to poor-quality
signals being passed to the CNN and consequently misclassified.
\strong{Use tailfindr input at your own risk.}
}

\examples{
\dontrun{

df <- ninetails::convert_tailfindr_output(
  tailfindr_output = '/path/to/tailfindr_out.csv')

# The output can be passed to the ninetails pipeline as the
# nanopolish argument:
results <- ninetails::check_tails(
  nanopolish = df,
  sequencing_summary = '/path/to/sequencing_summary.txt',
  workspace = '/path/to/workspace',
  num_cores = 2,
  basecall_group = 'Basecall_1D_000',
  pass_only = TRUE,
  save_dir = '~/Downloads')

}
}
\seealso{
\code{\link{check_polya_length_filetype}} which uses this
  function internally,
  \code{\link{check_tails_guppy}} for the legacy pipeline that accepts the
  converted output as its \code{nanopolish} argument,
  \code{\link{extract_polya_data}} for how nanopolish output is
  normally processed.
}
