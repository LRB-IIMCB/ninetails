% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/ninetails_training_dataset_production_functions.R
\name{filter_nonA_chunks_trainingset}
\alias{filter_nonA_chunks_trainingset}
\title{Filters read chunks containing non-adenosine nucleotides of interest for
neural network training-set preparation.}
\usage{
filter_nonA_chunks_trainingset(tail_chunk_list, value, num_cores)
}
\arguments{
\item{tail_chunk_list}{List object produced by
\code{\link{create_tail_chunk_list_trainingset}}.}

\item{value}{Numeric \code{[1]}. Controls whether valleys (C/U) or peaks
  (G) are retained:
\describe{
  \item{-1}{Retain chunks containing valleys (C or U nucleotides).}
  \item{1}{Retain chunks containing peaks (G nucleotide).}
}}

\item{num_cores}{Numeric \code{[1]}. Number of physical cores to use.
Do not exceed 1 less than the number of cores at your disposal.}
}
\value{
A named list of filtered chunk sublists, where names correspond
  to read IDs. Empty reads (no chunks passing the filter) are removed.
}
\description{
Designed for use with synthetic spike-in data containing a single type
of non-A residue (G, C, or U in the context of 3'-homopolymer A). The
function retains only chunks whose pseudomove vectors contain a
consecutive run of the specified \code{value} (peak or valley) of
length >= 4 and whose start position is non-negative.
}
\details{
The filtering takes advantage of the characteristic pseudomove
patterns produced by the z-score signal filter:
\itemize{
  \item G nucleotides produce a \strong{peak} (pseudomove = +1).
  \item C and U nucleotides produce a \strong{valley} (pseudomove = -1).
}

The function does \emph{not} distinguish between C and U (both produce
valleys); classification is handled downstream by the CNN. Therefore
it is essential that training datasets for C and U differ in the
transcript bodies they map to and/or are not sequenced in a single run.

\strong{Important:} this function is \emph{not} suitable for preparing
the A-only reference set. Use
\code{\link{create_tail_feature_list_A}} for that purpose.

Before proceeding, visual inspection of at least some filtered signals
is advisable. It may be necessary to manually adjust hardcoded
parameters (contact the developer/maintainer for details).
}
\examples{
\dontrun{

# filtering G residue:
filter_nonA_chunks_trainingset(
  tail_chunk_list = list_object_with_tail_chunks,
  value = 1, num_cores = 2)

# filtering C/U (user must know which type of residue is dealt with):
filter_nonA_chunks_trainingset(
  tail_chunk_list = list_object_with_tail_chunks,
  value = -1, num_cores = 2)

}
}
\seealso{
\code{\link{create_tail_chunk_list_trainingset}} for the
  preceding pipeline step,
  \code{\link{create_gaf_list}} for GAF conversion downstream,
  \code{\link{prepare_trainingset}} for the top-level wrapper.
}
