% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ninetails_check_tails.R
\name{check_tails}
\alias{check_tails}
\title{Wrapper function for complete DRS processing by ninetails package (legacy mode).}
\usage{
check_tails(
  polya_data,
  sequencing_summary,
  workspace,
  num_cores = 1,
  basecall_group = "Basecall_1D_000",
  pass_only = TRUE,
  qc = TRUE,
  save_dir,
  prefix = "",
  part_size = 1e+06
)
}
\arguments{
\item{polya_data}{character string. Full path of the .tsv file produced
by either nanopolish polya function or tailfindr. Only DRS-derived tables are
accepted. In case of tailfindr output, it would be immediately converted to
nanopolish-like format.}

\item{sequencing_summary}{character string. Full path of the .txt file
with sequencing summary.}

\item{workspace}{character string. Full path of the directory to search the
basecalled fast5 files in. The Fast5 files have to be multi-fast5 file.}

\item{num_cores}{numeric [1]. Number of physical cores to use in processing
the data. Do not exceed 1 less than the number of cores at your disposal.
This parameter is set to 1 by default.}

\item{basecall_group}{character string ["Basecall_1D_000"]. Name of the
level in the Fast5 file hierarchy from which the data should be extracted.
This parameter is set to 'Basecall_1D_000' by default.}

\item{pass_only}{logical [TRUE/FALSE]. If TRUE, only reads tagged by
nanopolish as "PASS" would be taken into consideration. Otherwise, reads
tagged as "PASS" & "SUFFCLIP" will be taken into account in analysis.
As a default, "TRUE" value is set.}

\item{qc}{logical [TRUE/FALSE]. If TRUE, the quality control of the output
predictions would be performed. This means that the reads/non-A residue
positions in terminal nucleotides, which are most likely artifacts, are
labeled accordingly as "-WARN" (residues recognized as non-A due to
nanopolish segmentation error which is inherited from nanopolish,
as ninetails uses nanopolish segmentation). It is then up to user, whether
they would like to include or discard such reads from their pipeline. However,
it is advised to treat them with caution. By default, the qc option is enabled
(this parameter is set to TRUE).}

\item{save_dir}{character string. Full path of the directory where the output
files containing the tail composition information should be stored.}

\item{prefix}{character string (optional). If provided, it will be inserted
into the names of the output files, positioned between the timestamp
and the suffix indicating the file type (either read classes or
nonadenosine residues).}

\item{part_size}{numeric [100000] (optional). If provided, defines maximum
number of rows in the poly(A) length containing input processed at once.
This value must be >=1000 (defaults to 1000000).If the size of
nanopolish/tailfindr output exceeds default 100000 rows, the input dataframe
would be splitted into parts and processed sequentially to avoid memory
overflow and pipeline crush.}
}
\value{
A list containing tail information organized by the read ID
is returned. Always assign this returned list to a variable, otherwise
the long list will be printed to the console, which may crash your R session.
Also a log file as well as read_classes & nonadenosine_residues files
are created in the user-specified directory.
}
\description{
Important note: Due to updates from Oxford Nanopore Technologies
including the transition from the Guppy basecaller to Dorado,
a shift in the preferred native data format from FAST5 to POD5,
and a change in sequencing chemistry from R9 to R10,
the analysis pipeline based on Guppy outputs and Nanopolish/Tailfindr
poly(A) tail estimates has been moved to legacy mode.
To ensure backward compatibility with direct RNA sequencing (DRS) data
generated using earlier chemistries and algorithms,
this processing pipeline (previously implemented as
`check_tails()` in earlier versions of *ninetails*)
is now maintained as `check_tails_guppy()`.
}
\details{
This function accepts either nanopolish or tailfindr outputs.

This function allows to perform all of the steps required to discover
nonadenosine nucleotides within the given dataset using ninetails.
Please keep in mind, that during computations the function creates large
segmentation data. Therefore it may be wise to split the polya data table
beforehand and then run this function on table chunks.

The output of this function is a list of 2 dataframes, containing:\itemize{
\item read_classes - classification of reads based on applied criteria
\item nonadenosine_residues - detailed positional info regarding all
potential nonadenosine residues detected.
}

The more detailed info regarding read classification is stored within
'comments' column. To make the output more compact, it contains codes
as follows:\itemize{
\item IRL - insufficient read length
\item QCF - nanopolish qc failed
\item MAU - move transition absent, nonA residue undetected
\item MPU - move transition present, nonA residue undetected
\item NIN - not included in the analysis (pass only = T)
\item YAY - move transition present, nonA residue detected
}

The filtering criteria applied by ninetails are as follows: move of value =1
present, qc_tag = "PASS" or "PASS" & "SUFFCLIP", length estimated
by nanopolish >=10 nt).
}
\examples{
\dontrun{

results <- ninetails::check_tails(
 polya_data = system.file('extdata',
                          'test_data',
                          'nanopolish_output.tsv',
                          package = 'ninetails'),
 sequencing_summary = system.file('extdata',
                                  'test_data',
                                  'sequencing_summary.txt',
                                  package = 'ninetails'),
 workspace = system.file('extdata',
                         'test_data',
                         'basecalled_fast5',
                         package = 'ninetails'),
 num_cores = 2,
 basecall_group = 'Basecall_1D_000',
 pass_only=TRUE,
 qc=TRUE,
 save_dir = '~/Downloads',
 prefix = "prefix",
 part_size=2000)

}
}
