% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ninetails_data_postprocessing_functions.R
\name{reclassify_ninetails_data}
\alias{reclassify_ninetails_data}
\title{Reclassifies ambiguous nonA residues to mitigate potential errors inherited
from nanopolish segmentation}
\usage{
reclassify_ninetails_data(
  residue_data,
  class_data,
  grouping_factor = NULL,
  transcript_column,
  ref = NULL
)
}
\arguments{
\item{residue_data}{[dataframe] A dataframe or tibble containig non-A residue
predictions made by ninetails pipeline}

\item{class_data}{[dataframe] A dataframe or tibble containing read_classes
predictions made by ninetails pipeline}

\item{grouping_factor}{[character string]. A grouping variable (e.g. "sample_name")}

\item{transcript_column}{[character string]. Name of column containing transcript id
(e.g. "ensembl_transcript_id_short")}

\item{ref}{[character string] or object or NULL (default) - the whitelist of transcripts
with hybrid tails - containing 3'UTRs highly enriched with A nucleotides (in last 20
positions >80%).
Current version of ninetails contains built-in whitelists, which may be selected
by the user:\itemize{
\item 'athaliana' - Arabidopsis thaliana
\item 'hsapiens' - Homo sapiens
\item 'mmusculus' - Mus musculus
\item 'scerevisiae' - Saccharomyces cerevisiae
\item 'celegans' - Caenorhabditis elegans
\item 'tbrucei' - Trypanosoma brucei
}
It is also possible to provide own whitelist. Important note: whitelist must be consistent
with the content of the 'transcript_column'. Using whitelist is not mandatory,
however it allows to retrieve more true positive data.}
}
\value{
A [list] with 2 dataframes containing class_data and residue_data, respectively,
with corrections for classified data applied.
}
\description{
In the current version, ninetails does not segment reads on its own,
but inherits segmentation from nanopolish. This segmentation is not ideal.
Sometimes nucleotides from the 3' ends of some AT-rich transcripts
are misidentified as poly(A) tails, when in fact they are still nucleotides
belonging to the body of the transcript. In the case of such transcripts,
a very large enrichment of non-A positions in close proximity to the body
of the transcript is observed (peak distribution).
}
\details{
If the tail boundaries are recognized incorrectly in the transcript,
this results in an accumulation of non-A positions detected near
the 3'end of the transcript. This, in turn, significantly affects
the results of the analysis. To minimize the impact of potential
segmentation artifacts, you can use this function to filter out
such ambiguous nonA positions.

This function takes as input the raw outputs of the ninetails pipeline
(class_data and residue_data), preferably loaded using the read_class_*
and read_residue_* functions. It also requires a grouping variable name
(grouping_factor) and a name of column containing the IDs of the transcripts
(e.g. "contig", "transcript", "ensembl_transcript_id_short", etc.) desired
by the user.

The output contains headers identical to those present in the raw ninetails
outputs. They are fully compatible with the rest of the functions of the
package, such as those for data visualization.

---CAUTION---

Reads that contain only non-A nucleotides that are likely to be nanopolish
artifacts are reclassified in the class_data table as "unmodified" ("class"
column), and their comment is changed from "YAY" to "MPU" ("comments" column).
}
\examples{
\dontrun{

rec_results <- ninetails::reclassify_ninetails_data(residue_data=results[[2]],
                                                    class_data=results[[1]],
                                                    transcript_column = "contig")
 }

}
